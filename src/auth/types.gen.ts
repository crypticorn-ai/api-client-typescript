// This file is auto-generated by @hey-api/openapi-ts

/**
 * The error information
 */
export type error_BAD_REQUEST = {
  /**
   * The error message
   */
  message: string;
  /**
   * The error code
   */
  code: string;
  /**
   * An array of issues that were responsible for the error
   */
  issues?: Array<{
    message: string;
  }>;
};

/**
 * The error information
 */
export type error_FORBIDDEN = {
  /**
   * The error message
   */
  message: string;
  /**
   * The error code
   */
  code: string;
  /**
   * An array of issues that were responsible for the error
   */
  issues?: Array<{
    message: string;
  }>;
};

/**
 * The error information
 */
export type error_INTERNAL_SERVER_ERROR = {
  /**
   * The error message
   */
  message: string;
  /**
   * The error code
   */
  code: string;
  /**
   * An array of issues that were responsible for the error
   */
  issues?: Array<{
    message: string;
  }>;
};

/**
 * The error information
 */
export type error_NOT_FOUND = {
  /**
   * The error message
   */
  message: string;
  /**
   * The error code
   */
  code: string;
  /**
   * An array of issues that were responsible for the error
   */
  issues?: Array<{
    message: string;
  }>;
};

/**
 * The error information
 */
export type error_UNAUTHORIZED = {
  /**
   * The error message
   */
  message: string;
  /**
   * The error code
   */
  code: string;
  /**
   * An array of issues that were responsible for the error
   */
  issues?: Array<{
    message: string;
  }>;
};

export type LogoutResponse = unknown;

export type LogoutError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type WhoamiResponse = {
  email: string;
  id: string;
  name: string | null;
  picture: string | null;
  username: string | null;
  phone: string | null;
  isAdmin: boolean;
};

export type WhoamiError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type CreateUserData = {
  body: {
    /**
     * Email address for email signup
     */
    email: string;
    /**
     * Password for email signup.
     */
    password?: string;
    /**
     * Username for the user
     */
    username?: string;
    /**
     * Display name for the user
     */
    name?: string;
    /**
     * Profile picture for the user
     */
    picture?: string;
    /**
     * Phone number for the user
     */
    phone?: string;
    /**
     * OOB code to use when overwriting a password-less account.
     */
    oob?: string;
  };
};

export type CreateUserResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
  /**
   * The oob code to use when creating a password-less user. This is only returned if the user is created without a password.
   */
  oobCode?: string;
};

export type CreateUserError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type ResendVerificationEmailData = {
  body: {
    email: string;
  };
};

export type ResendVerificationEmailResponse = unknown;

export type ResendVerificationEmailError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type VerifyEmailData = {
  body: {
    oobCode: string;
  };
};

export type VerifyEmailResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth?: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type VerifyEmailError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UpdateUserData = {
  body: {
    id: string;
    name?: string;
    email?: string;
    username?: string;
    picture?: string;
  };
};

export type UpdateUserResponse = unknown;

export type UpdateUserError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UserByIdData = {
  query: {
    id: string;
  };
};

export type UserByIdResponse = {
  email: string;
  id: string;
  name: string | null;
  picture: string | null;
  username: string | null;
  phone: string | null;
  isAdmin: boolean;
};

export type UserByIdError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type UserByUsernameData = {
  query: {
    username: string;
  };
};

export type UserByUsernameResponse = {
  userId: string;
  username: string | null;
  name: string | null;
};

export type UserByUsernameError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type UserListResponse = Array<{
  email: string;
  id: string;
  name: string | null;
  picture: string | null;
  username: string | null;
  phone: string | null;
  isAdmin: boolean;
}>;

export type UserListError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type SendPasswordResetEmailData = {
  body: {
    email: string;
  };
};

export type SendPasswordResetEmailResponse = unknown;

export type SendPasswordResetEmailError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UserSetPasswordData = {
  body: {
    id: string;
    newPassword: string;
  };
};

export type UserSetPasswordResponse = unknown;

export type UserSetPasswordError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UserResetPasswordData = {
  body: {
    oobCode: string;
    password: string;
  };
};

export type UserResetPasswordResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth?: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type UserResetPasswordError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type LinkLicenseData = {
  body: {
    license: string;
  };
};

export type LinkLicenseResponse = unknown;

export type LinkLicenseError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UnlinkLicenseResponse = unknown;

export type UnlinkLicenseError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type GetLicenseResponse = {
  /**
   * The redacted license key for the user.
   */
  key: string | null;
  hasLicense: boolean;
};

export type GetLicenseError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type RotateTokensResponse = {
  accessToken: string;
  refreshToken: string;
  auth: {
    /**
     * Issuer
     */
    iss?: string;
    /**
     * Subject
     */
    sub?: string;
    /**
     * Audience
     */
    aud?: string;
    /**
     * Expiration time
     */
    exp?: number;
    /**
     * Not valid before time
     */
    nbf?: number;
    /**
     * Issued at time
     */
    iat?: number;
    /**
     * JWT ID
     */
    jti?: string;
    /**
     * Whether the user is an admin
     */
    admin?: boolean;
    /**
     * Scopes
     */
    scopes?: Array<string>;
  };
};

export type RotateTokensError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type RefreshTokenScopesResponse = {
  accessToken: string;
  refreshToken: string;
  auth: {
    /**
     * Issuer
     */
    iss?: string;
    /**
     * Subject
     */
    sub?: string;
    /**
     * Audience
     */
    aud?: string;
    /**
     * Expiration time
     */
    exp?: number;
    /**
     * Not valid before time
     */
    nbf?: number;
    /**
     * Issued at time
     */
    iat?: number;
    /**
     * JWT ID
     */
    jti?: string;
    /**
     * Whether the user is an admin
     */
    admin?: boolean;
    /**
     * Scopes
     */
    scopes?: Array<string>;
  };
};

export type RefreshTokenScopesError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type RevokeAllSessionsResponse = {
  count: number;
};

export type RevokeAllSessionsError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type RevokeUserTokensData = {
  body: {
    userId: string;
  };
};

export type RevokeUserTokensResponse = {
  message: string;
};

export type RevokeUserTokensError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type RefreshTokenInfoResponse = {
  userSession: {
    /**
     * ID of the user session
     */
    id: string;
    /**
     * User ID of the user session
     */
    user_id: string;
    /**
     * Token of the user session
     */
    token: string;
    /**
     * Expiration time of the user session
     */
    expires_at: string;
    /**
     * Client IP address of the user session
     */
    client_ip: string | null;
    /**
     * User agent of the user session
     */
    user_agent: string | null;
  };
};

export type RefreshTokenInfoError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type TokenInfoResponse = {
  payload?: {
    /**
     * Issuer
     */
    iss?: string;
    /**
     * Subject
     */
    sub?: string;
    /**
     * Audience
     */
    aud?: string;
    /**
     * Expiration time
     */
    exp?: number;
    /**
     * Not valid before time
     */
    nbf?: number;
    /**
     * Issued at time
     */
    iat?: number;
    /**
     * JWT ID
     */
    jti?: string;
    /**
     * Whether the user is an admin
     */
    admin?: boolean;
    /**
     * Scopes
     */
    scopes?: Array<string>;
  };
};

export type TokenInfoError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type AuthorizeUserData = {
  body: {
    /**
     * Email of the user
     */
    email: string;
    /**
     * Password of the user
     */
    password: string;
    /**
     * Captcha token of the authorization request
     */
    captchaToken: string;
  };
};

export type AuthorizeUserResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type AuthorizeUserError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type GetGoogleAuthUrlData = {
  query: {
    oobCode?: string;
    origin: string;
  };
};

export type GetGoogleAuthUrlResponse = string;

export type GetGoogleAuthUrlError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type OauthCallbackData = {
  query: {
    authuser: string;
    code: string;
    origin: string;
    prompt: string;
    scope: string;
    state?: string;
  };
};

export type OauthCallbackResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type OauthCallbackError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type VerifyResponse = {
  /**
   * Issuer
   */
  iss?: string;
  /**
   * Subject
   */
  sub?: string;
  /**
   * Audience
   */
  aud?: string;
  /**
   * Expiration time
   */
  exp?: number;
  /**
   * Not valid before time
   */
  nbf?: number;
  /**
   * Issued at time
   */
  iat?: number;
  /**
   * JWT ID
   */
  jti?: string;
  /**
   * Whether the user is an admin
   */
  admin?: boolean;
  /**
   * Scopes
   */
  scopes?: Array<string>;
};

export type VerifyError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type VerifyApiKeyData = {
  query: {
    apiKey: string;
  };
};

export type VerifyApiKeyResponse = {
  /**
   * Issuer
   */
  iss?: string;
  /**
   * Subject
   */
  sub?: string;
  /**
   * Audience
   */
  aud?: string;
  /**
   * Expiration time
   */
  exp?: number;
  /**
   * Not valid before time
   */
  nbf?: number;
  /**
   * Issued at time
   */
  iat?: number;
  /**
   * JWT ID
   */
  jti?: string;
  /**
   * Whether the user is an admin
   */
  admin?: boolean;
  /**
   * Scopes
   */
  scopes?: Array<string>;
};

export type VerifyApiKeyError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type GetApiKeysResponse = Array<{
  /**
   * ID of the API key
   */
  id: string;
  /**
   * User ID of the API key
   */
  user_id: string;
  /**
   * Scopes of the API key
   */
  scopes: Array<
    | 'read:hive:model'
    | 'read:hive:data'
    | 'write:hive:model'
    | 'read:trade:bots'
    | 'write:trade:bots'
    | 'read:trade:exchangekeys'
    | 'write:trade:exchangekeys'
    | 'read:trade:orders'
    | 'read:trade:actions'
    | 'write:trade:actions'
    | 'read:trade:exchanges'
    | 'read:trade:futures'
    | 'write:trade:futures'
    | 'read:trade:notifications'
    | 'write:trade:notifications'
    | 'read:trade:strategies'
    | 'write:trade:strategies'
    | 'read:pay:payments'
    | 'read:pay:products'
    | 'write:pay:products'
    | 'write:pay:coupons'
    | 'read:pay:coupons'
    | 'write:pay:invoices'
    | 'read:metrics:marketcap'
    | 'read:metrics:indicators'
    | 'read:metrics:exchanges'
    | 'read:metrics:tokens'
    | 'read:metrics:markets'
    | 'read:indicator:news'
    | 'read:indicator:sentiment'
    | 'read:predictions'
    | 'write:predictions'
    | 'read:polymarket:predictions'
    | 'write:polymarket:predictions'
    | 'read:klines'
    | 'read:notifications:broadcast-settings'
    | 'write:notifications:broadcast-settings'
    | 'read:notifications:user-settings'
    | 'write:notifications:user-settings'
    | 'read:notifications:notifications'
    | 'write:notifications:notifications'
    | 'send:notifications:notifications'
    | 'read:prometheus:metrics'
    | 'read:dex:signals'
  >;
  /**
   * Name of the API key
   */
  name: string;
  /**
   * Expiration time of the API key as a date
   */
  expires_at?: string | null;
  /**
   * Creation time of the API key as a date
   */
  created_at: string;
  /**
   * IP addresses that can access the API key. If empty, the API key will be accessible from any IP address.
   */
  ip_whitelist?: Array<string>;
}>;

export type GetApiKeysError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type CreateApiKeyData = {
  body: {
    /**
     * Name of the API key
     */
    name: string;
    /**
     * Scopes of the API key
     */
    scopes: Array<
      | 'read:hive:model'
      | 'read:hive:data'
      | 'write:hive:model'
      | 'read:trade:bots'
      | 'write:trade:bots'
      | 'read:trade:exchangekeys'
      | 'write:trade:exchangekeys'
      | 'read:trade:orders'
      | 'read:trade:actions'
      | 'write:trade:actions'
      | 'read:trade:exchanges'
      | 'read:trade:futures'
      | 'write:trade:futures'
      | 'read:trade:notifications'
      | 'write:trade:notifications'
      | 'read:trade:strategies'
      | 'write:trade:strategies'
      | 'read:pay:payments'
      | 'read:pay:products'
      | 'write:pay:products'
      | 'write:pay:coupons'
      | 'read:pay:coupons'
      | 'write:pay:invoices'
      | 'read:metrics:marketcap'
      | 'read:metrics:indicators'
      | 'read:metrics:exchanges'
      | 'read:metrics:tokens'
      | 'read:metrics:markets'
      | 'read:indicator:news'
      | 'read:indicator:sentiment'
      | 'read:predictions'
      | 'write:predictions'
      | 'read:polymarket:predictions'
      | 'write:polymarket:predictions'
      | 'read:klines'
      | 'read:notifications:broadcast-settings'
      | 'write:notifications:broadcast-settings'
      | 'read:notifications:user-settings'
      | 'write:notifications:user-settings'
      | 'read:notifications:notifications'
      | 'write:notifications:notifications'
      | 'send:notifications:notifications'
      | 'read:prometheus:metrics'
      | 'read:dex:signals'
    >;
    /**
     * Expiration time of the API key as a date
     */
    expires_at?: string;
    /**
     * IP addresses that can access the API key. If empty, the API key will be accessible from any IP address.
     */
    ip_whitelist?: Array<string>;
  };
};

export type CreateApiKeyResponse = {
  apiKey: string;
};

export type CreateApiKeyError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type DeleteApiKeyData = {
  query: {
    id: string;
  };
};

export type DeleteApiKeyResponse = unknown;

export type DeleteApiKeyError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type GetUserScopesResponse = Array<
  | 'read:hive:model'
  | 'read:hive:data'
  | 'write:hive:model'
  | 'read:trade:bots'
  | 'write:trade:bots'
  | 'read:trade:exchangekeys'
  | 'write:trade:exchangekeys'
  | 'read:trade:orders'
  | 'read:trade:actions'
  | 'write:trade:actions'
  | 'read:trade:exchanges'
  | 'read:trade:futures'
  | 'write:trade:futures'
  | 'read:trade:notifications'
  | 'write:trade:notifications'
  | 'read:trade:strategies'
  | 'write:trade:strategies'
  | 'read:pay:payments'
  | 'read:pay:products'
  | 'write:pay:products'
  | 'write:pay:coupons'
  | 'read:pay:coupons'
  | 'write:pay:invoices'
  | 'read:metrics:marketcap'
  | 'read:metrics:indicators'
  | 'read:metrics:exchanges'
  | 'read:metrics:tokens'
  | 'read:metrics:markets'
  | 'read:indicator:news'
  | 'read:indicator:sentiment'
  | 'read:predictions'
  | 'write:predictions'
  | 'read:polymarket:predictions'
  | 'write:polymarket:predictions'
  | 'read:klines'
  | 'read:notifications:broadcast-settings'
  | 'write:notifications:broadcast-settings'
  | 'read:notifications:user-settings'
  | 'write:notifications:user-settings'
  | 'read:notifications:notifications'
  | 'write:notifications:notifications'
  | 'send:notifications:notifications'
  | 'read:prometheus:metrics'
  | 'read:dex:signals'
>;

export type GetUserScopesError =
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type GetScopesByUserIdData = {
  query: {
    userId: string;
  };
};

export type GetScopesByUserIdResponse = Array<
  | 'read:hive:model'
  | 'read:hive:data'
  | 'write:hive:model'
  | 'read:trade:bots'
  | 'write:trade:bots'
  | 'read:trade:exchangekeys'
  | 'write:trade:exchangekeys'
  | 'read:trade:orders'
  | 'read:trade:actions'
  | 'write:trade:actions'
  | 'read:trade:exchanges'
  | 'read:trade:futures'
  | 'write:trade:futures'
  | 'read:trade:notifications'
  | 'write:trade:notifications'
  | 'read:trade:strategies'
  | 'write:trade:strategies'
  | 'read:pay:payments'
  | 'read:pay:products'
  | 'write:pay:products'
  | 'write:pay:coupons'
  | 'read:pay:coupons'
  | 'write:pay:invoices'
  | 'read:metrics:marketcap'
  | 'read:metrics:indicators'
  | 'read:metrics:exchanges'
  | 'read:metrics:tokens'
  | 'read:metrics:markets'
  | 'read:indicator:news'
  | 'read:indicator:sentiment'
  | 'read:predictions'
  | 'write:predictions'
  | 'read:polymarket:predictions'
  | 'write:polymarket:predictions'
  | 'read:klines'
  | 'read:notifications:broadcast-settings'
  | 'write:notifications:broadcast-settings'
  | 'read:notifications:user-settings'
  | 'write:notifications:user-settings'
  | 'read:notifications:notifications'
  | 'write:notifications:notifications'
  | 'send:notifications:notifications'
  | 'read:prometheus:metrics'
  | 'read:dex:signals'
>;

export type GetScopesByUserIdError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type VerifyBasicAuthData = {
  query: {
    password: string;
    username: string;
  };
};

export type VerifyBasicAuthResponse = {
  /**
   * Issuer
   */
  iss?: string;
  /**
   * Subject
   */
  sub?: string;
  /**
   * Audience
   */
  aud?: string;
  /**
   * Expiration time
   */
  exp?: number;
  /**
   * Not valid before time
   */
  nbf?: number;
  /**
   * Issued at time
   */
  iat?: number;
  /**
   * JWT ID
   */
  jti?: string;
  /**
   * Whether the user is an admin
   */
  admin?: boolean;
  /**
   * Scopes
   */
  scopes?: Array<string>;
};

export type VerifyBasicAuthError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type GenerateOtpCodeData = {
  body: {
    /**
     * The user id to generate the OTP code for.
     */
    userId: string;
  };
};

export type GenerateOtpCodeResponse = unknown;

export type GenerateOtpCodeError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type VerifyOtpCodeData = {
  body: {
    /**
     * The user id to verify the OTP code for. Only respected if the user is an admin. Default is the current user.
     */
    userId: string;
    /**
     * The OTP code to verify.
     */
    otpCode: string;
  };
};

export type VerifyOtpCodeResponse = {
  verified: boolean;
};

export type VerifyOtpCodeError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type AddWalletData = {
  body: {
    host: string;
    origin: string;
    address: string;
    chainId?: number;
    statement?: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type AddWalletResponse = {
  oobCode: string;
  message: string;
};

export type AddWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UpdateWalletData = {
  body: {
    /**
     * Display name for the wallet
     */
    name: string;
    /**
     * ID of the wallet
     */
    id: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type UpdateWalletResponse = unknown;

export type UpdateWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type VerifyWalletData = {
  body: {
    oobCode: string;
    signature: string;
    message: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type VerifyWalletResponse = unknown;

export type VerifyWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type UnlinkWalletData = {
  body: {
    id: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type UnlinkWalletResponse = unknown;

export type UnlinkWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type ListWalletsData = {
  headers?: {
    'X-Refresh-Token'?: string;
  };
  query?: {
    userId?: string;
  };
};

export type ListWalletsResponse = {
  data: Array<{
    id: string;
    user_id: string;
    name: string | null;
    address: string | null;
    verified_at: string | null;
  }>;
  count: number;
};

export type ListWalletsError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type WalletVerifiedData = {
  headers?: {
    'X-Refresh-Token'?: string;
  };
  query: {
    address: string;
  };
};

export type WalletVerifiedResponse = {
  verified: boolean;
};

export type WalletVerifiedError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_NOT_FOUND
  | error_INTERNAL_SERVER_ERROR;

export type WalletNonceData = {
  body: {
    host: string;
    origin: string;
    address: string;
    chainId?: number;
    statement?: string;
    /**
     * If true, will raise an error if the wallet is not found
     */
    raiseIfNew?: boolean;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type WalletNonceResponse = {
  oobCode: string;
  message: string;
};

export type WalletNonceError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type AuthorizeWalletData = {
  body: {
    oobCode: string;
    signature: string;
    message: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type AuthorizeWalletResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type AuthorizeWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;

export type CreateUserWithWalletData = {
  body: {
    /**
     * OOB Code returned from walletNonce. This method must be called before creating a user with a wallet.
     */
    oobCode: string;
    /**
     * Signature returned from the EVM client when signing the message returned from walletNonce. This method must be called before creating a user with a wallet.
     */
    signature: string;
    /**
     * Message returned from walletNonce. This method must be called before creating a user with a wallet.
     */
    message: string;
    /**
     * Username for the user
     */
    username?: string;
    /**
     * Display name for the user
     */
    name?: string;
    /**
     * Profile picture for the user
     */
    picture?: string;
    /**
     * Phone number for the user
     */
    phone?: string;
  };
  headers?: {
    'X-Refresh-Token'?: string;
  };
};

export type CreateUserWithWalletResponse = {
  user: {
    email: string;
    id: string;
    name: string | null;
    picture: string | null;
    username: string | null;
    phone: string | null;
    isAdmin: boolean;
  };
  auth: {
    accessToken: string;
    refreshToken: string;
    auth: {
      /**
       * Issuer
       */
      iss?: string;
      /**
       * Subject
       */
      sub?: string;
      /**
       * Audience
       */
      aud?: string;
      /**
       * Expiration time
       */
      exp?: number;
      /**
       * Not valid before time
       */
      nbf?: number;
      /**
       * Issued at time
       */
      iat?: number;
      /**
       * JWT ID
       */
      jti?: string;
      /**
       * Whether the user is an admin
       */
      admin?: boolean;
      /**
       * Scopes
       */
      scopes?: Array<string>;
    };
  };
};

export type CreateUserWithWalletError =
  | error_BAD_REQUEST
  | error_UNAUTHORIZED
  | error_FORBIDDEN
  | error_INTERNAL_SERVER_ERROR;
