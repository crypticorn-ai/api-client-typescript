// This file is auto-generated by @hey-api/openapi-ts

/**
 * Unique identifier of the API error.
 */
export type ApiErrorIdentifier =
  | "allocation_below_current_exposure"
  | "allocation_below_min_amount"
  | "black_swan"
  | "bot_already_deleted"
  | "bot_disabled"
  | "bot_stopping_completed"
  | "bot_stopping_started"
  | "client_order_id_already_exists"
  | "invalid_content_type"
  | "delete_bot_error"
  | "exchange_invalid_signature"
  | "exchange_invalid_timestamp"
  | "exchange_ip_address_is_not_authorized"
  | "exchange_key_already_exists"
  | "exchange_key_in_use"
  | "exchange_system_under_maintenance"
  | "exchange_rate_limit_exceeded"
  | "insufficient_permissions_spot_and_futures_required"
  | "exchange_service_temporarily_unavailable"
  | "exchange_system_is_busy"
  | "exchange_system_configuration_error"
  | "exchange_internal_system_error"
  | "exchange_user_account_is_frozen"
  | "api_key_expired"
  | "bearer_token_expired"
  | "forbidden"
  | "hedge_mode_not_active"
  | "http_request_error"
  | "insufficient_balance"
  | "insufficient_margin"
  | "insufficient_scopes"
  | "invalid_api_key"
  | "invalid_bearer"
  | "invalid_data"
  | "invalid_data_response"
  | "invalid_exchange_key"
  | "invalid_margin_mode"
  | "invalid_model_name"
  | "invalid_parameter_provided"
  | "leverage_limit_exceeded"
  | "order_violates_liquidation_price_constraints"
  | "model_name_not_unique"
  | "no_credentials"
  | "now_api_down"
  | "object_already_exists"
  | "object_created"
  | "object_deleted"
  | "object_not_found"
  | "object_updated"
  | "order_is_already_filled"
  | "order_is_being_processed"
  | "order_quantity_limit_exceeded"
  | "order_does_not_exist"
  | "order_price_is_invalid"
  | "order_size_too_large"
  | "order_size_too_small"
  | "position_limit_exceeded"
  | "position_does_not_exist"
  | "position_opening_temporarily_suspended"
  | "post_only_order_would_immediately_match"
  | "request_scope_limit_exceeded"
  | "risk_limit_exceeded"
  | "rpc_timeout"
  | "system_settlement_in_process"
  | "strategy_already_exists"
  | "strategy_disabled"
  | "strategy_leverage_mismatch"
  | "strategy_not_supporting_exchange"
  | "success"
  | "symbol_does_not_exist"
  | "trading_action_expired"
  | "trading_action_skipped"
  | "trading_has_been_locked"
  | "trading_is_suspended"
  | "unknown_error_occurred"
  | "requested_resource_not_found";

/**
 * Level of the API error.
 */
export type ApiErrorLevel = "error" | "info" | "success" | "warning";

/**
 * Type of the API error.
 */
export type ApiErrorType =
  | "user error"
  | "exchange error"
  | "server error"
  | "no error";

/**
 * All existing coins. Some might no be available in the latest data version, but kept for older versions.
 */
export type Coins = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10";

/**
 * The response for a data download request
 */
export type DataDownloadResponse = {
  /**
   * The coin the data is for
   */
  coin: Coins;
  /**
   * The feature size the data is for
   */
  feature_size: FeatureSize;
  /**
   * The version of the data
   */
  version: DataVersion;
  /**
   * The target of the data
   */
  target: Target;
  links: DownloadLinks;
};

/**
 * The complete data information for all versions, coins, feature sizes and targets
 */
export type DataInfo = {
  /**
   * The complete data information for all versions, coins, feature sizes and targets.
   */
  data: {
    [key: string]: {
      [key: string]: DataOptions;
    };
  };
  /**
   * The coins available on the latest data version.
   */
  coins: Array<Coins>;
  /**
   * The feature sizes available on the latest data version.
   */
  feature_sizes: Array<FeatureSize>;
  /**
   * The targets available on the latest data version.
   */
  targets: Array<TargetInfo>;
  /**
   * All ever existing data versions. Some may not be publicly available yet.
   */
  all_versions: Array<DataVersionInfo>;
  /**
   * All publicly available data versions.
   */
  available_versions: Array<DataVersionInfo>;
};

export type DataOptions = {
  /**
   * The targets available on the latest data version.
   */
  targets: Array<Target>;
  /**
   * The feature sizes available on the latest data version.
   */
  feature_sizes: Array<FeatureSize>;
};

/**
 * All existing data versions
 */
export type DataVersion = "1.0";

export type DataVersionInfo = {
  /**
   * Data version
   */
  version: DataVersion;
  /**
   * Release date of the data version in unix timestamp
   */
  release_date: number;
};

/**
 * The download links for the data
 */
export type DownloadLinks = {
  /**
   * The download link for the y_train data
   */
  y_train: string;
  /**
   * The download link for the X_test data
   */
  X_test: string;
  /**
   * The download link for the X_train data
   */
  X_train: string;
};

/**
 * Pydantic model for model evaluation data
 */
export type Evaluation = {
  /**
   * Evaluation timestamp
   */
  timestamp: number;
  /**
   * Evaluation score
   */
  score: number;
};

/**
 * Pydantic model for evaluation response
 */
export type EvaluationResponse = {
  /**
   * Evaluation metrics
   */
  metrics: {
    [key: string]: number;
  };
};

/**
 * Exception details returned to the client.
 */
export type ExceptionDetail = {
  /**
   * An additional error message
   */
  message?: string | null;
  /**
   * The unique error code
   */
  code: ApiErrorIdentifier;
  /**
   * The type of error
   */
  type: ApiErrorType;
  /**
   * The level of the error
   */
  level: ApiErrorLevel;
  /**
   * The HTTP status code
   */
  status_code: number;
  /**
   * Additional details about the error
   */
  details?: unknown;
};

/**
 * All existing feature sizes. Some might no be available in the latest data version, but kept for older versions.
 */
export type FeatureSize = "small" | "medium" | "large";

export type LogLevel = "DEBUG" | "INFO" | "WARNING" | "ERROR" | "CRITICAL";

/**
 * Base Pydantic model for model data
 */
export type ModelCreate = {
  /**
   * Coin ID for the model
   */
  coin_id: Coins;
  /**
   * Target variable for the model
   */
  target: Target;
  /**
   * Model name
   */
  name: string;
};

/**
 * Pydantic model for model response
 */
export type ModelRead = {
  /**
   * Unique model identifier
   */
  id: number;
  /**
   * Model name
   */
  name: string;
  /**
   * Coin ID
   */
  coin_id: Coins;
  /**
   * Target variable
   */
  target: Target;
  /**
   * Model status
   */
  status: ModelStatus;
  /**
   * Target type
   */
  target_type: TargetType;
  /**
   * Model evaluations
   */
  evaluations: Array<Evaluation>;
  /**
   * Developer user ID
   */
  user_id: string;
  /**
   * Model creation unix timestamp
   */
  created_at: number;
  /**
   * Model update unix timestamp
   */
  updated_at: number;
};

/**
 * Enum for model status
 */
export type ModelStatus = "created" | "evaluated";

/**
 * Pydantic model for model update
 */
export type ModelUpdate = {
  /**
   * Model name
   */
  name: string;
};

/**
 * All existing targets. Some might no be available in the latest data version, but kept for older versions.
 */
export type Target = "Tatooine" | "Alderaan" | "Hoth";

/**
 * Information about a target
 */
export type TargetInfo = {
  /**
   * Target name
   */
  name: Target;
  /**
   * Target type
   */
  type: TargetType;
  /**
   * Data version
   */
  version: DataVersion;
};

/**
 * The type of the target
 */
export type TargetType = "continuous" | "binary";

export type PingResponse = string;

export type PingError = ExceptionDetail;

export type GetTimeData = {
  query?: {
    type?: "iso" | "unix";
  };
};

export type GetTimeResponse = string;

export type GetTimeError = ExceptionDetail;

export type CreateModelData = {
  body: ModelCreate;
};

export type CreateModelResponse = ModelRead;

export type CreateModelError = ExceptionDetail;

export type EvaluateModelData = {
  body: Array<unknown>;
  path: {
    /**
     * The ID of the model you want to evaluate.
     */
    id: number;
  };
  query?: {
    /**
     * Data version for evaluation. Defaults to latest public version. Using older versions won't affect leaderboard rankings but can be useful for additional model testing.
     */
    version?: DataVersion | null;
  };
};

export type EvaluateModelResponse = EvaluationResponse;

export type EvaluateModelError = ExceptionDetail;

export type GetModelData = {
  path: {
    /**
     * The ID of the model to retrieve.
     */
    id: number;
  };
};

export type GetModelResponse = ModelRead;

export type GetModelError = ExceptionDetail;

export type DeleteModelData = {
  path: {
    /**
     * The ID of the model to delete.
     */
    id: number;
  };
};

export type DeleteModelResponse = void;

export type DeleteModelError = ExceptionDetail;

export type UpdateModelData = {
  body: ModelUpdate;
  path: {
    /**
     * The ID of the model to update.
     */
    id: number;
  };
};

export type UpdateModelResponse = unknown;

export type UpdateModelError = ExceptionDetail;

export type GetModelByNameData = {
  path: {
    /**
     * The name of the model to get.
     */
    name: string;
  };
};

export type GetModelByNameResponse = ModelRead;

export type GetModelByNameError = ExceptionDetail;

export type GetModelsData = {
  query?: {
    /**
     * Whether to get models by a specific user. Else all models are returned.
     */
    by_user?: boolean;
    /**
     * The ID of the user to get models for. Only used if `by_user` is true. Default is current user.
     */
    user_id?: string;
  };
};

export type GetModelsResponse = Array<ModelRead>;

export type GetModelsError = ExceptionDetail;

export type DownloadDataData = {
  query: {
    /**
     * The number of features in the data. Default is `LARGE`.
     */
    feature_size?: FeatureSize | null;
    /**
     * The ID of the model to download data for.
     */
    model_id: number;
    /**
     * The version of the data to download. Default is the latest public version.
     */
    version?: DataVersion | null;
  };
};

export type DownloadDataResponse = DataDownloadResponse;

export type DownloadDataError = ExceptionDetail;

export type GetDataInfoResponse = DataInfo;

export type GetDataInfoError = ExceptionDetail;

export type GetLogLevelResponse = LogLevel;

export type GetLogLevelError = ExceptionDetail;

export type GetUptimeData = {
  query?: {
    type?: "seconds" | "human";
  };
};

export type GetUptimeResponse = string;

export type GetUptimeError = ExceptionDetail;

export type GetMemoryUsageResponse = number;

export type GetMemoryUsageError = ExceptionDetail;

export type GetThreadsResponse = {
  [key: string]: unknown;
};

export type GetThreadsError = ExceptionDetail;

export type GetContainerLimitsResponse = {
  [key: string]: unknown;
};

export type GetContainerLimitsError = ExceptionDetail;

export type GetDependenciesData = {
  query?: {
    /**
     * List of regex patterns to match against package names. If not provided, all installed packages will be returned.
     */
    include?: Array<string>;
  };
};

export type GetDependenciesResponse = {
  [key: string]: string;
};

export type GetDependenciesError = ExceptionDetail;
