// This file is auto-generated by @hey-api/openapi-ts

/**
 * The number of actions for a user by day
 */
export type ActionsCount = {
  /**
   * Timestamp of the latest action for the day
   */
  timestamp: number;
  /**
   * The number of actions for the day
   */
  count: number;
};

/**
 * Unique identifier of the API error.
 */
export type ApiErrorIdentifier =
  | "allocation_below_current_exposure"
  | "allocation_below_min_amount"
  | "allocation_limit_exceeded"
  | "black_swan"
  | "bot_already_deleted"
  | "bot_stopping_completed"
  | "bot_stopping_started"
  | "cancelled_open_order"
  | "client_order_id_already_exists"
  | "invalid_content_type"
  | "coupon_invalid"
  | "delete_bot_error"
  | "exchange_http_request_error"
  | "exchange_invalid_parameter"
  | "exchange_invalid_signature"
  | "exchange_invalid_timestamp"
  | "exchange_ip_address_is_not_authorized"
  | "exchange_key_already_exists"
  | "exchange_key_in_use"
  | "exchange_system_under_maintenance"
  | "exchange_rate_limit_exceeded"
  | "insufficient_permissions_spot_and_futures_required"
  | "exchange_service_temporarily_unavailable"
  | "exchange_system_is_busy"
  | "exchange_system_configuration_error"
  | "exchange_internal_system_error"
  | "exchange_user_account_is_frozen"
  | "api_key_expired"
  | "bearer_token_expired"
  | "failed_open_order"
  | "forbidden"
  | "hedge_mode_not_active"
  | "insufficient_balance"
  | "insufficient_margin"
  | "insufficient_scopes"
  | "invalid_api_key"
  | "invalid_basic_auth"
  | "invalid_bearer"
  | "invalid_data"
  | "invalid_data_response"
  | "invalid_exchange_key"
  | "invalid_model_name"
  | "leverage_limit_exceeded"
  | "order_violates_liquidation_price_constraints"
  | "margin_mode_clash"
  | "name_not_unique"
  | "no_credentials"
  | "now_api_down"
  | "object_already_exists"
  | "object_created"
  | "object_deleted"
  | "object_locked"
  | "object_not_found"
  | "object_updated"
  | "order_is_already_filled"
  | "order_is_being_processed"
  | "order_quantity_limit_exceeded"
  | "order_does_not_exist"
  | "order_price_is_invalid"
  | "order_size_too_large"
  | "order_size_too_small"
  | "orphan_open_order"
  | "orphan_close_order"
  | "position_limit_exceeded"
  | "position_does_not_exist"
  | "position_opening_temporarily_suspended"
  | "post_only_order_would_immediately_match"
  | "request_scope_limit_exceeded"
  | "risk_limit_exceeded"
  | "rpc_timeout"
  | "system_settlement_in_process"
  | "strategy_disabled"
  | "strategy_leverage_mismatch"
  | "strategy_not_supporting_exchange"
  | "success"
  | "symbol_does_not_exist"
  | "trading_action_expired"
  | "trading_action_skipped_bot_stopping"
  | "trading_has_been_locked"
  | "trading_is_suspended"
  | "unknown_error_occurred"
  | "requested_resource_not_found";

/**
 * Level of the API error.
 */
export type ApiErrorLevel = "error" | "info" | "success" | "warning";

/**
 * Type of the API error.
 */
export type ApiErrorType =
  | "user error"
  | "exchange error"
  | "server error"
  | "no error";

/**
 * Trading bot model for read operations.
 */
export type Bot = {
  /**
   * UID for the user
   */
  user_id: string;
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * Name of the bot
   */
  name: string;
  /**
   * Initial allocation for the bot
   */
  allocation: number;
  /**
   * Status of the bot
   */
  status: BotStatus;
  /**
   * UID for the trading strategy used by the bot
   */
  strategy_id: string;
  /**
   * UID for the API key
   */
  api_key_id: string;
  /**
   * Status code of the bot. Set if the bot is stopped by an error.
   */
  status_code: ApiErrorIdentifier | null;
  /**
   * Initial allocation for the bot + accumulated PnL of the orders after the last allocation change
   */
  current_allocation: string;
  /**
   * Current exposure of the bot, aka. the sum of the absolute values of the open positions
   */
  current_exposure: string;
};

/**
 * Trading bot model for API create operations.
 */
export type BotCreate = {
  /**
   * Name of the bot
   */
  name: string;
  /**
   * Initial allocation for the bot
   */
  allocation: number;
  /**
   * Status of the bot
   */
  status: BotStatus;
  /**
   * UID for the trading strategy used by the bot
   */
  strategy_id: string;
  /**
   * UID for the API key
   */
  api_key_id: string;
};

export type BotStatus = "running" | "stopping" | "stopped" | "deleted";

/**
 * Trading bot model for API update operations. Fields cannot be unset.
 */
export type BotUpdate = {
  /**
   * Name of the bot
   */
  name?: string | null;
  /**
   * Initial allocation for the bot
   */
  allocation?: number | null;
  /**
   * Status of the bot
   */
  status?: BotStatus | null;
};

/**
 * Exception details returned to the client.
 */
export type ExceptionDetail = {
  /**
   * An additional error message
   */
  message?: string | null;
  /**
   * The unique error code
   */
  code: ApiErrorIdentifier;
  /**
   * The type of error
   */
  type: ApiErrorType;
  /**
   * The level of the error
   */
  level: ApiErrorLevel;
  /**
   * The HTTP status code
   */
  status_code: number;
  /**
   * Additional details about the error
   */
  details?: unknown;
};

/**
 * All exchanges used in the crypticorn ecosystem. Refer to the APIs for support for a specific usecase (data, trading, etc.).
 */
export type Exchange =
  | "kucoin"
  | "bingx"
  | "binance"
  | "bybit"
  | "hyperliquid"
  | "bitget"
  | "gateio"
  | "bitstamp";

/**
 * Model for exchange info
 */
export type ExchangeInfo = {
  /**
   * Exchange
   */
  exchange: Exchange;
  /**
   * Whether the exchange is tradeable (trade execution is implemented)
   */
  is_tradeable: boolean;
  /**
   * Whether the exchange is in public beta testing (marked as beta in the UI)
   */
  is_beta: boolean;
  /**
   * Whether the exchange is public (shown in the UI)
   */
  is_public: boolean;
  /**
   * Whether the exchange is planned to be added (marked as planned but disabled in the UI)
   */
  is_planned: boolean;
  /**
   * Whether the exchange is deprecated (not supported anymore)
   */
  is_deprecated: boolean;
  /**
   * Reference link to the exchange
   */
  ref_link?: string | null;
};

/**
 * Exchange API key model without sensitive credentials for safe read operations.
 */
export type ExchangeKey = {
  /**
   * UID for the user
   */
  user_id: string;
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * Label for the API key
   */
  label: string;
  /**
   * The exchange the API key is for.
   */
  exchange: Exchange;
  /**
   * Whether the API key has been deleted.
   */
  deleted: boolean;
};

/**
 * Balance information for an exchange API key including futures and spot balances.
 */
export type ExchangeKeyBalance = {
  /**
   * API key ID.
   */
  api_key_id: string;
  /**
   * Futures balance information.
   */
  futures: FuturesBalance;
  /**
   * Spot balance information.
   */
  spot: Array<SpotBalance>;
};

/**
 * Exchange key model for API create operations.
 */
export type ExchangeKeyCreate = {
  /**
   * Label for the API key
   */
  label: string;
  /**
   * API key
   */
  api_key: string;
  /**
   * API secret
   */
  secret: string;
  /**
   * API passphrase. Required by some exchanges.
   */
  passphrase?: string | null;
  /**
   * The exchange the API key is for.
   */
  exchange: Exchange;
};

/**
 * Exchange key model for API update operations.
 */
export type ExchangeKeyUpdate = {
  /**
   * Label for the API key
   */
  label?: string | null;
  /**
   * API key
   */
  api_key?: string | null;
  /**
   * API secret
   */
  secret?: string | null;
  /**
   * API passphrase. Required by some exchanges.
   */
  passphrase?: string | null;
};

/**
 * Execution IDs for trading actions including main order and stop loss/take profit orders.
 */
export type ExecutionIds = {
  /**
   * Main execution ID.
   */
  main: string;
  /**
   * Stop loss execution IDs. List with multiple items ordered by the next stop loss, e.g. price = 10000 => SLs: ['900', '700', '500'].
   */
  sl: Array<string>;
  /**
   * Take profit execution IDs. List with multiple items ordered by the next take profit, e.g. price = 10000 => TPs: ['1100', '1300', '1500'].
   */
  tp: Array<string>;
};

/**
 * Model for futures balance
 */
export type FuturesBalance = {
  /**
   * Asset the balance values are in
   */
  asset: string;
  /**
   * Net asset value including unrealized profit and loss
   */
  equity: number;
  /**
   * Actual account balance (equity - unrealized)
   */
  balance: number;
  /**
   * Available balance for trading/withdrawal
   */
  available: number;
  /**
   * Unrealized profit and loss
   */
  unrealized: number;
  /**
   * Margin used in open positions
   */
  used: number;
  /**
   * Frozen funds not available for use
   */
  frozen: number;
  /**
   * Allocated balance for bots. Added on runtime.
   */
  allocated?: number | null;
};

/**
 * Model for futures trading actions
 */
export type FuturesTradingAction = {
  /**
   * Leverage to use for futures trades. Default is 1.
   */
  leverage: number;
  /**
   * Margin mode for futures trades. Default is isolated.
   */
  margin_mode: MarginMode;
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * UID for the execution of the order. Leave empty for open actions. Required on close actions if you have placed a TP/SL before. A specific TP/SL execution ID of the opening order. The allocation should match the TP/SL allocation you set.
   */
  execution_id: string | null;
  /**
   * UID for the order to close. Leave empty for open actions. Required on close actions. The main execution ID of the opening order.
   */
  open_order_execution_id: string | null;
  /**
   * The type of action.
   */
  action_type: TradingActionType;
  /**
   * The type of market the action is for.
   */
  market_type: MarketType;
  /**
   * UID for the strategy.
   */
  strategy_id: string;
  /**
   * Trading symbol or asset pair in format: 'symbol/quote_currency' (see market service for valid symbols)
   */
  symbol: string;
  /**
   * Whether this is a limit order. Default is False.
   */
  is_limit: boolean | null;
  /**
   * The limit price for limit orders. If not set, the market price will be used.
   */
  limit_price: string | null;
  /**
   * How much of bot's balance to use for the order (for open actions). How much of the reference open order (open_order_execution_id) to close (for close actions). 0=0%, 1=100%.
   */
  allocation: string;
  /**
   * Take profit targets. Sorted ascending (for long actions) or descending (for short actions) by delta to market price
   */
  take_profit: Array<TPSL> | null;
  /**
   * Stop loss values. Sorted ascending (for long actions) or descending (for short actions) by delta to market price
   */
  stop_loss: Array<TPSL> | null;
  /**
   * Timestamp of when the order will expire. If not set, the order will not expire. Applied on each bot individually.
   */
  expiry_timestamp: number | null;
};

/**
 * Model for sending futures trading actions to the API
 */
export type FuturesTradingActionCreate = {
  /**
   * Leverage to use for futures trades. Default is 1.
   */
  leverage?: number;
  /**
   * Margin mode for futures trades. Default is isolated.
   */
  margin_mode?: MarginMode;
  /**
   * UID for the execution of the order. Leave empty for open actions. Required on close actions if you have placed a TP/SL before. A specific TP/SL execution ID of the opening order. The allocation should match the TP/SL allocation you set.
   */
  execution_id?: string | null;
  /**
   * UID for the order to close. Leave empty for open actions. Required on close actions. The main execution ID of the opening order.
   */
  open_order_execution_id?: string | null;
  /**
   * The type of action.
   */
  action_type: TradingActionType;
  /**
   * The type of market the action is for. Must be set to futures.
   */
  market_type?: MarketType;
  /**
   * UID for the strategy.
   */
  strategy_id: string;
  /**
   * Trading symbol or asset pair in format: 'symbol/quote_currency' (see market service for valid symbols)
   */
  symbol: string;
  /**
   * Whether this is a limit order. Default is False.
   */
  is_limit?: boolean | null;
  /**
   * The limit price for limit orders. If not set, the market price will be used.
   */
  limit_price?: string | null;
  /**
   * How much of bot's balance to use for the order (for open actions). How much of the reference open order (open_order_execution_id) to close (for close actions). 0=0%, 1=100%.
   */
  allocation: string;
  /**
   * Take profit targets. Can be set for open actions only. Multiple can be set.
   */
  take_profit?: Array<TPSLCreate> | null;
  /**
   * Stop loss values. Can be set for open actions only. Multiple can be set.
   */
  stop_loss?: Array<TPSLCreate> | null;
  /**
   * Timestamp of when the order will expire. If not set, the order will not expire. Applied on each bot individually.
   */
  expiry_timestamp?: number | null;
};

/**
 * Margin mode for futures trades
 */
export type MarginMode = "isolated" | "cross";

/**
 * Market types
 */
export type MarketType = "spot" | "futures";

/**
 * Notification model for read operations.
 */
export type Notification = {
  /**
   * UID for the user
   */
  user_id: string;
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * Whether the notification has been marked as seen
   */
  viewed: boolean;
  /**
   * Whether the notification has been sent as an email
   */
  sent: boolean;
  /**
   * Identifier string. Must match the mapping key in the frontend.
   */
  identifier: ApiErrorIdentifier;
  /**
   * Level of the notification. Of type ApiErrorLevel
   */
  level: ApiErrorLevel;
  /**
   * Type of the notification. Of type ApiErrorType
   */
  type: ApiErrorType;
};

/**
 * Notification model for creating new system alerts and messages.
 */
export type NotificationCreate = {
  /**
   * Whether the notification has been marked as seen
   */
  viewed?: boolean;
  /**
   * Whether the notification has been sent as an email
   */
  sent?: boolean;
  /**
   * Identifier string. Must match the mapping key in the frontend.
   */
  identifier: ApiErrorIdentifier;
  /**
   * Level of the notification. Of type ApiErrorLevel
   */
  level: ApiErrorLevel;
  /**
   * Type of the notification. Of type ApiErrorType
   */
  type: ApiErrorType;
};

/**
 * Notification model for API update operations.
 */
export type NotificationUpdate = {
  /**
   * Whether the notification has been marked as seen
   */
  viewed?: boolean | null;
  /**
   * Whether the notification has been sent as an email
   */
  sent?: boolean | null;
};

/**
 * Response model for orders. This is the model that is returned by the API and the database.
 */
export type Order = {
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * Exchange name. Of type Exchange
   */
  exchange: Exchange;
  /**
   * Trading symbol on exchange
   */
  symbol: string;
  /**
   * Type of trading action. Of type TradingActionType
   */
  action_type: TradingActionType;
  /**
   * Trade status of the order. Of type OrderStatus
   */
  status: OrderStatus;
  /**
   * Market type of the order. Of type MarketType
   */
  market_type: MarketType;
  /**
   * UID for the trading action that placed the order
   */
  trading_action_id: string | null;
  /**
   * UID for the execution (not unique to the bot)
   */
  execution_id: string | null;
  /**
   * UID for the order on the exchange
   */
  exchange_order_id: string | null;
  /**
   * UID for the position
   */
  position_id: string | null;
  /**
   * UID for the API key
   */
  api_key_id: string | null;
  /**
   * UID for the user
   */
  user_id: string | null;
  /**
   * UID for the bot
   */
  bot_id: string | null;
  /**
   * Client order ID
   */
  client_order_id: string | null;
  /**
   * Common trading symbol
   */
  common_symbol: string | null;
  /**
   * Price of the order
   */
  price: string;
  /**
   * Margin mode of the order. Of type MarginMode
   */
  margin_mode: MarginMode | null;
  /**
   * API error identifier. Of type ApiErrorIdentifier
   */
  status_code: ApiErrorIdentifier | null;
  /**
   * Percentage of the order filled
   */
  filled_perc: string;
  /**
   * Quantity filled. Needed for pnl calculation. In the symbol's base currency.
   */
  filled_qty: string;
  /**
   * Quantity sent to the exchange. In the symbol's base currency.
   */
  sent_qty: string;
  /**
   * Fees for the order as a negative value
   */
  fee: string | null;
  /**
   * Leverage for the order
   */
  leverage: number | null;
  /**
   * Exchange specific details of the order
   */
  order_details: {
    [key: string]: unknown;
  };
  /**
   * Profit and loss for the order
   */
  pnl: string | null;
  /**
   * Timestamp of order creation on the exchange in seconds since epoch. None if the order is not placed.
   */
  order_time: number | null;
  /**
   * Whether the order is a lost order. These are orders that are not filled and recognizable by us.
   */
  is_lost: boolean | null;
};

/**
 * The number of orders for a user by day
 */
export type OrdersCount = {
  /**
   * Timestamp of the latest order for the day
   */
  timestamp: number;
  /**
   * The number of orders for the day
   */
  count: number;
};

/**
 * Status of the order
 */
export type OrderStatus =
  | "new"
  | "filled"
  | "partially_filled"
  | "cancelled"
  | "failed";

export type PaginatedResponse_FuturesTradingAction_ = {
  data: Array<FuturesTradingAction>;
  /**
   * The total number of items
   */
  total: number;
  /**
   * The current page number
   */
  page: number;
  /**
   * The number of items per page
   */
  page_size: number;
  /**
   * The previous page number
   */
  prev?: number | null;
  /**
   * The next page number
   */
  next?: number | null;
  /**
   * The last page number
   */
  last?: number | null;
};

export type PaginatedResponse_Order_ = {
  data: Array<Order>;
  /**
   * The total number of items
   */
  total: number;
  /**
   * The current page number
   */
  page: number;
  /**
   * The number of items per page
   */
  page_size: number;
  /**
   * The previous page number
   */
  prev?: number | null;
  /**
   * The next page number
   */
  next?: number | null;
  /**
   * The last page number
   */
  last?: number | null;
};

/**
 * The profit and loss of a bot by timestamp. In the case of sampling, the PnL is the sum of the PnLs between the prior timestamp and the current timestamp.
 */
export type PnL = {
  /**
   * Timestamp of the order
   */
  timestamp: number;
  /**
   * The profit and loss of the order
   */
  pnl: number;
  /**
   * The cumulative profit and loss of the bot until the order (inclusive)
   */
  cum_pnl: number;
};

/**
 * The response when posting a futures action
 */
export type PostFuturesAction = {
  /**
   * Action ID.
   */
  id: string;
  /**
   * Execution IDs for the action.
   */
  execution_ids: ExecutionIds;
};

/**
 * Model for spot balance
 */
export type SpotBalance = {
  /**
   * Asset/Currency code
   */
  asset: string;
  /**
   * Balance of the asset
   */
  balance: number;
  /**
   * Available balance for trading/withdrawal
   */
  available: number;
  /**
   * Frozen funds not available for use
   */
  frozen: number;
  /**
   * Allocated balance for bots. Added on runtime.
   */
  allocated?: number | null;
};

/**
 * Model for sending spot trading actions to the API
 */
export type SpotTradingActionCreate = {
  /**
   * UID for the execution of the order. Leave empty for open actions. Required on close actions if you have placed a TP/SL before. A specific TP/SL execution ID of the opening order. The allocation should match the TP/SL allocation you set.
   */
  execution_id?: string | null;
  /**
   * UID for the order to close. Leave empty for open actions. Required on close actions. The main execution ID of the opening order.
   */
  open_order_execution_id?: string | null;
  /**
   * The type of action.
   */
  action_type: TradingActionType;
  /**
   * The type of market the action is for. Must be set to spot.
   */
  market_type?: MarketType;
  /**
   * UID for the strategy.
   */
  strategy_id: string;
  /**
   * Trading symbol or asset pair in format: 'symbol/quote_currency' (see market service for valid symbols)
   */
  symbol: string;
  /**
   * Whether this is a limit order. Default is False.
   */
  is_limit?: boolean | null;
  /**
   * The limit price for limit orders. If not set, the market price will be used.
   */
  limit_price?: string | null;
  /**
   * How much of bot's balance to use for the order (for open actions). How much of the reference open order (open_order_execution_id) to close (for close actions). 0=0%, 1=100%.
   */
  allocation: string;
  /**
   * Take profit targets. Can be set for open actions only. Multiple can be set.
   */
  take_profit?: Array<TPSLCreate> | null;
  /**
   * Stop loss values. Can be set for open actions only. Multiple can be set.
   */
  stop_loss?: Array<TPSLCreate> | null;
  /**
   * Timestamp of when the order will expire. If not set, the order will not expire. Applied on each bot individually.
   */
  expiry_timestamp?: number | null;
};

/**
 * Strategy model for read operations.
 */
export type Strategy = {
  /**
   * Timestamp of creation
   */
  created_at: number | null;
  /**
   * Timestamp of last update
   */
  updated_at: number | null;
  /**
   * Unique identifier for the resource
   */
  id: string | null;
  /**
   * Name of the strategy
   */
  name: string;
  /**
   * Description of the strategy
   */
  description: string;
  /**
   * Exchanges supported by the strategy.
   */
  exchanges: Array<StrategyExchangeInfo>;
  /**
   * Whether the strategy is enabled. If false, no bots will be created or updated for this strategy, open trades will be rejected. Existing bots will be marked as stopping.
   */
  enabled: boolean;
  /**
   * Performance fee for the strategy
   */
  performance_fee: number;
  /**
   * Unique human readable identifier for the strategy e.g. 'daily_trend_momentum'
   */
  identifier: string;
  /**
   * Margin mode to use for the strategy. Not allowed for spot strategies. Must be set for futures strategies.
   */
  margin_mode: MarginMode | null;
  /**
   * Leverage for the strategy
   */
  leverage: number;
  /**
   * Market of operation of the strategy
   */
  market_type: MarketType;
};

/**
 * Strategy model for API create operations.
 */
export type StrategyCreate = {
  /**
   * Name of the strategy
   */
  name: string;
  /**
   * Description of the strategy
   */
  description: string;
  /**
   * Exchanges supported by the strategy.
   */
  exchanges: Array<StrategyExchangeInfo>;
  /**
   * Whether the strategy is enabled. If false, no bots will be created or updated for this strategy, open trades will be rejected. Existing bots will be marked as stopping.
   */
  enabled: boolean;
  /**
   * Performance fee for the strategy
   */
  performance_fee: number;
  /**
   * Unique human readable identifier for the strategy e.g. 'daily_trend_momentum'
   */
  identifier: string;
  /**
   * Margin mode to use for the strategy. Not allowed for spot strategies. Must be set for futures strategies.
   */
  margin_mode?: MarginMode | null;
  /**
   * Leverage for the strategy
   */
  leverage: number;
  /**
   * Market of operation of the strategy
   */
  market_type: MarketType;
};

export type StrategyExchangeInfo = {
  /**
   * Exchange name. Of type Exchange
   */
  exchange: Exchange;
  /**
   * Base asset for the strategy. This is the asset that will be used to trade with. Default is USDT.
   */
  base_asset?: string;
  /**
   * Minimum amount for the strategy on the exchange in the base asset.
   */
  min_amount: number;
  /**
   * Maximum amount for the strategy on the exchange in the base asset.
   */
  max_amount?: number;
};

/**
 * Strategy model for API update operations. Fields cannot be unset.
 */
export type StrategyUpdate = {
  /**
   * Name of the strategy
   */
  name?: string | null;
  /**
   * Description of the strategy
   */
  description?: string | null;
  /**
   * Exchanges supported by the strategy.
   */
  exchanges?: Array<StrategyExchangeInfo> | null;
  /**
   * Whether the strategy is enabled. If false, no bots will be created or updated for this strategy, open trades will be rejected. Existing bots will be marked as stopping.
   */
  enabled?: boolean | null;
  /**
   * Performance fee for the strategy
   */
  performance_fee?: number | null;
};

/**
 * Runtime fields for take profit and stop loss
 */
export type TPSL = {
  /**
   * The price delta to calculate the limit price from the current market price, e.g. 1.01 for a TP of 1% on long
   */
  price_delta: string;
  /**
   * Percentage of the open order to sell. All allocations must sum up to 1. Use this allocation again when closing the order.
   */
  allocation: string;
  /**
   * Execution ID of the order.
   */
  execution_id?: string | null;
};

/**
 * Model for take profit and stop loss
 */
export type TPSLCreate = {
  /**
   * The price delta to calculate the limit price from the current market price, e.g. 1.01 for a TP of 1% on long
   */
  price_delta: string;
  /**
   * Percentage of the open order to sell. All allocations must sum up to 1. Use this allocation again when closing the order.
   */
  allocation: string;
};

/**
 * Type of trading action
 */
export type TradingActionType =
  | "open_long"
  | "open_short"
  | "close_long"
  | "close_short";

export type GetBotOrdersCountData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
  query?: {
    /**
     * The group by period for the orders count. Defaults to day.
     */
    group_by?: "day" | "week" | "month" | "year";
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetBotOrdersCountResponse = Array<OrdersCount>;

export type GetBotOrdersCountError = ExceptionDetail;

export type GetBotsOrdersCountData = {
  query?: {
    /**
     * The group by period for the orders count. Defaults to day.
     */
    group_by?: "day" | "week" | "month" | "year";
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetBotsOrdersCountResponse = Array<OrdersCount>;

export type GetBotsOrdersCountError = ExceptionDetail;

export type GetBotOrdersPnlData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
  query?: {
    /**
     * The number of items to return. Defaults to None, meaning no limit.
     */
    limit?: number | null;
    /**
     * The number of days to return the PnL for. Only used if `window` is `period`. Default is 30.
     */
    period?: number | null;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Defaults to the authenticated user, unless user is an admin.
     */
    user_id?: string | null;
    /**
     * Time window for PnL. Defaults to full (all time), or use period (last X days), month, quarter, or year for values since the start of that range.
     */
    window?: "period" | "month" | "quarter" | "year" | "full";
  };
};

export type GetBotOrdersPnlResponse = Array<PnL>;

export type GetBotOrdersPnlError = ExceptionDetail;

export type GetBotsOrdersPnlData = {
  query?: {
    /**
     * The number of items to return. Defaults to None, meaning no limit.
     */
    limit?: number | null;
    /**
     * The number of days to return the PnL for. Only used if `window` is `period`. Default is 30.
     */
    period?: number | null;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Defaults to the authenticated user, unless user is an admin.
     */
    user_id?: string | null;
    /**
     * Time window for PnL. Defaults to full (all time), or use period (last X days), month, quarter, or year for values since the start of that range.
     */
    window?: "period" | "month" | "quarter" | "year" | "full";
  };
};

export type GetBotsOrdersPnlResponse = Array<PnL>;

export type GetBotsOrdersPnlError = ExceptionDetail;

export type GetBotsOrdersData = {
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * The current page number
     */
    page?: number | null;
    /**
     * The number of items per page. Default is 100, max is 1000.
     */
    page_size?: number;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Overrides the authenticated user if provided and the user is an admin.
     */
    user_id?: string | null;
  };
};

export type GetBotsOrdersResponse = PaginatedResponse_Order_;

export type GetBotsOrdersError = ExceptionDetail;

export type GetBotOrdersData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * The current page number
     */
    page?: number | null;
    /**
     * The number of items per page. Default is 100, max is 1000.
     */
    page_size?: number;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Overrides the authenticated user if provided and the user is an admin.
     */
    user_id?: string | null;
  };
};

export type GetBotOrdersResponse = PaginatedResponse_Order_;

export type GetBotOrdersError = ExceptionDetail;

export type GetBotsActionsData = {
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * The current page number
     */
    page?: number | null;
    /**
     * The number of items per page. Default is 100, max is 1000.
     */
    page_size?: number;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Overrides the authenticated user if provided and the user is an admin.
     */
    user_id?: string | null;
  };
};

export type GetBotsActionsResponse = PaginatedResponse_FuturesTradingAction_;

export type GetBotsActionsError = ExceptionDetail;

export type GetBotActionsData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * The current page number
     */
    page?: number | null;
    /**
     * The number of items per page. Default is 100, max is 1000.
     */
    page_size?: number;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
    /**
     * The ID of the user. Overrides the authenticated user if provided and the user is an admin.
     */
    user_id?: string | null;
  };
};

export type GetBotActionsResponse = PaginatedResponse_FuturesTradingAction_;

export type GetBotActionsError = ExceptionDetail;

export type GetBotsData = {
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * Whether to include deleted bots. Filter by status takes precedence over this. Defaults to True.
     */
    include_deleted?: boolean;
    /**
     * Whether to validate the bots. Defaults to True.
     */
    should_validate?: boolean;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetBotsResponse = Array<Bot>;

export type GetBotsError = ExceptionDetail;

export type CreateBotData = {
  body: BotCreate;
};

export type CreateBotResponse = Bot;

export type CreateBotError = ExceptionDetail;

export type GetBotData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
};

export type GetBotResponse = Bot;

export type GetBotError = ExceptionDetail;

export type UpdateBotData = {
  body: BotUpdate;
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
};

export type UpdateBotResponse = Bot;

export type UpdateBotError = ExceptionDetail;

export type DeleteBotData = {
  path: {
    /**
     * The ID of the bot
     */
    id: string;
  };
};

export type DeleteBotResponse = void;

export type DeleteBotError = ExceptionDetail;

export type GetExchangeKeysData = {
  query?: {
    /**
     * The field to filter by
     */
    filter_by?: string | null;
    /**
     * The value to filter with
     */
    filter_value?: string | null;
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetExchangeKeysResponse = Array<ExchangeKey>;

export type GetExchangeKeysError = ExceptionDetail;

export type CreateExchangeKeyData = {
  body: ExchangeKeyCreate;
};

export type CreateExchangeKeyResponse = ExchangeKey;

export type CreateExchangeKeyError = ExceptionDetail;

export type GetExchangeKeyBalancesResponse = Array<ExchangeKeyBalance>;

export type GetExchangeKeyBalancesError = ExceptionDetail;

export type GetExchangeKeyByIdData = {
  path: {
    /**
     * The ID of the API key to get.
     */
    id: string;
  };
};

export type GetExchangeKeyByIdResponse = ExchangeKey;

export type GetExchangeKeyByIdError = ExceptionDetail;

export type DeleteExchangeKeyData = {
  path: {
    /**
     * The ID of the API key to delete.
     */
    id: string;
  };
};

export type DeleteExchangeKeyResponse = void;

export type DeleteExchangeKeyError = ExceptionDetail;

export type UpdateExchangeKeyData = {
  body: ExchangeKeyUpdate;
  path: {
    /**
     * The ID of the API key to update.
     */
    id: string;
  };
};

export type UpdateExchangeKeyResponse = ExchangeKey;

export type UpdateExchangeKeyError = ExceptionDetail;

export type PostFuturesActionData = {
  body: FuturesTradingActionCreate;
};

export type PostFuturesActionResponse = PostFuturesAction;

export type PostFuturesActionError = ExceptionDetail;

export type PostSpotActionData = {
  body: SpotTradingActionCreate;
};

export type PostSpotActionResponse = unknown;

export type PostSpotActionError = ExceptionDetail;

export type GetActionsCountData = {
  query?: {
    /**
     * The group by period for the actions count. Defaults to day.
     */
    group_by?: "day" | "week" | "month" | "year";
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetActionsCountResponse = Array<ActionsCount>;

export type GetActionsCountError = ExceptionDetail;

export type GetOrdersCountData = {
  query?: {
    /**
     * The group by period for the orders count. Defaults to day.
     */
    group_by?: "day" | "week" | "month" | "year";
    /**
     * The field to sort by
     */
    sort_by?: string | null;
    /**
     * The order to sort by
     */
    sort_order?: "asc" | "desc" | null;
  };
};

export type GetOrdersCountResponse = Array<OrdersCount>;

export type GetOrdersCountError = ExceptionDetail;

export type GetStrategiesData = {
  query?: {
    /**
     * Limit the number of strategies returned. 0 means no limit.
     */
    limit?: number;
    /**
     * Offset the number of strategies returned. 0 means no offset.
     */
    offset?: number;
  };
};

export type GetStrategiesResponse = Array<Strategy>;

export type GetStrategiesError = ExceptionDetail;

export type CreateStrategyData = {
  body: StrategyCreate;
};

export type CreateStrategyResponse = Strategy;

export type CreateStrategyError = ExceptionDetail;

export type GetStrategyUsageResponse = Array<[string, number]>;

export type GetStrategyUsageError = ExceptionDetail;

export type KillStrategyData = {
  path: {
    /**
     * The ID of the strategy to kill.
     */
    id: string;
  };
};

export type KillStrategyResponse = void;

export type KillStrategyError = ExceptionDetail;

export type UpdateStrategyData = {
  body: StrategyUpdate;
  path: {
    /**
     * The ID of the strategy to update.
     */
    id: string;
  };
};

export type UpdateStrategyResponse = Strategy;

export type UpdateStrategyError = ExceptionDetail;

export type GetNotificationsData = {
  query?: {
    limit?: number;
    offset?: number;
  };
};

export type GetNotificationsResponse = Array<Notification>;

export type GetNotificationsError = ExceptionDetail;

export type CreateNotificationData = {
  body: NotificationCreate;
};

export type CreateNotificationResponse = unknown;

export type CreateNotificationError = ExceptionDetail;

export type UpdateNotificationsData = {
  body: NotificationUpdate;
};

export type UpdateNotificationsResponse = void;

export type UpdateNotificationsError = ExceptionDetail;

export type DeleteNotificationsResponse = void;

export type DeleteNotificationsError = ExceptionDetail;

export type UpdateNotificationData = {
  body: NotificationUpdate;
  path: {
    id: string;
  };
};

export type UpdateNotificationResponse = void;

export type UpdateNotificationError = ExceptionDetail;

export type DeleteNotificationData = {
  path: {
    id: string;
  };
};

export type DeleteNotificationResponse = void;

export type DeleteNotificationError = ExceptionDetail;

export type GetExchangeInfosResponse = Array<ExchangeInfo>;

export type GetExchangeInfosError = ExceptionDetail;

export type PingResponse = string;

export type PingError = ExceptionDetail;

export type GetMetricsResponse = unknown;

export type GetMetricsError = ExceptionDetail;
